# νλΌλ―Έν„° μ²΄ν¬

μΌλ°μ μΌλ΅ νλΌλ―Έν„°λ” typeμ„ λ…μ‹ν•κ±°λ‚ μ΄κΈ°κ°’μΌλ΅ μ¦‰ valueλ΅ νƒ€μ…μ„ μ• μ μμΌλ‚ `corpList.forEach(corp => corp.display())`μ™€ κ°™μ€ κµ¬λ¬Έμ—μ„λ” νλΌλ―Έν„°μΈ corpμ νƒ€μ…μ΄ λ…μ‹λμ§€λ„ μ•μ•κ³  κ°’λ„ μ• μ μ—†λ‹¤.

μ΄λ° μ ν•μ νλΌλ―Έν„°μ νƒ€μ…μ„ μ•κΈ° μ„ν•΄μ„λ” `forEach` ν•¨μμ μ •μμ™€ `corpList`μ μ •μκΉμ§€ κ±°μ¤λ¬ μ¬λΌκ°€λ©΄μ„ νƒ€μ…μ„ μ¶”λ΅ ν•΄μ•Ό ν•λ‹¤.

ν„μ¬ νλΌλ―Έν„°λ“¤μ νƒ€μ… μ¶”λ΅ μ€ `inferTypeParameter()`μ—μ„ μ²λ¦¬ν•κ³  μλ”λ° μ΄ ν•¨μμ—μ„ νƒ€μ… μ¶”λ΅ μ„ ν•λ” κ²ƒμ μ¥λ‹¨μ μ„ μ μ‹ μ‚΄ν΄λ³΄λ©΄

### μ¥μ 

μ¥μ μ΄λΌκΈ° λ³΄λ‹¤λ” μ—¬κΈ°μ„ μ•ν•λ©΄ μ•λλ” μ΄μ κ°€ μλ‹¤.

`inferTypeParameter()`μ—μ„ νλΌλ―Έν„°μ— λ€ν• deepν• νƒ€μ… μ¶”λ΅ μ„ ν•μ§€ μ•κ³ (νƒ€μ…μ΄ λ…μ‹λμ–΄μ Έ μκ±°λ‚ ν•΄μ„ μ‰½κ² ν™•μΈν•  μ μλ” κ²½μ°λ§ μ²λ¦¬ν•κ³  λ¨λ¥΄λ” κ²½μ°μ—λ” any typeμ„ λ¦¬ν„΄ν•κ² ν•λ” λ“±) μ •ν™•ν•κ³  μ„Έλ°€ν• νλΌλ―Έν„°μ νƒ€μ… κ²€μ‚¬λ” Validatorμ—μ„ κ²€μ‚¬ν•κ² ν•  μλ„ μλ‹¤.

κ·Έλ°λ° μ΄λ ‡κ² ν•λ©΄ `firmList.forEach(e => { r.push(e.firms.toString()) })` μ΄λ° κµ¬λ¬Έμ—μ„ `e` λ‹¤μμ `firms`κ°€ μ λ€λ΅ μ„¤μ •λμ§€ μ•λ” λ¬Έμ κ°€ μƒκΈ΄λ‹¤. `toString`, `firms`λ¥Ό κ±°μ³ `e`μ scopeλ¥Ό κ³„μ‚°ν•  λ• `e`μ νƒ€μ…μ΄ anyλ΅ μ„¤μ •λμ–΄μ Έ μμΌλ©΄ `firms`λ” λ‹¨μν μ΄λ¦„λ§ μ΅΄μ¬ν•κ² λκ³  `e.firms`κ°€ μ¬λ°”λ¥Έ κ²ƒμΈμ§€ μ²λ¦¬ν•  μ μ—†κ² λλ‹¤. `firms`κ°€ astμƒμ—μ„ μ λ€λ΅ μ„¤μ •μ΄ λμ§€ μ•κΈ° λ•λ¬Έμ— `toString`λ„ λ¬Έμ κ°€ λλ‹¤. μ¦‰ νλΌλ―Έν„°μ νƒ€μ…μ„ scope λ‹¨κ³„μ—μ„ μ μ ν μ κ³µν•΄ μ£Όμ§€ λ»ν•λ©΄ `firms`μ™€ κ°™μ€ ν”„λ΅νΌν‹°μ μ„¤μ •μ΄ μ λ€λ΅ μ΄λ¤„μ§ μ μ—†λ” κ²ƒμ΄λ‹¤. μ΄ κ³Όμ •μ€ Languiumμ DocumentBuilderμ—μ„λ„ μ΄λ¤„μ§ μ μλ”λ° validatorλ¥Ό μ΄μ©ν• μ²λ¦¬λ” μ΄ κ³Όμ • μ΄ν›„μ— μ²λ¦¬λκΈ° λ•λ¬Έμ— λ„λ¬΄ λ¦λ‹¤.

λ `e`κ°€ μ“°μ΄λ” λ¨λ“  κ³³μ—μ„ μ΄λ―Έ any νƒ€μ…μΌλ΅ μΈμ‹ν•κΈ° λ•λ¬Έμ— λ‚μ¤‘μ— μ΄λ¥Ό λ¨λ‘ λ³΄μ •ν•΄ μ¤μ•Ό ν•λ” λ¬Έμ λ„ μμ„ μ μλ‹¤.

### λ‹¨μ 

κ·Έλμ„ νλΌλ―Έν„°μ νƒ€μ… μ¶”λ΅ μ„ `inferTypeParameter()`μ—μ„ μ²λ¦¬ν•κ² λλ©΄ κ°€μ¥ ν° λ¬Έμ λ” μ¬κ·€ μ°Έμ΅° λ¬Έμ κ°€ λ°μƒν•  μ μλ‹¤λ” κ²ƒμ΄λ‹¤.

νλΌλ―Έν„°μ νƒ€μ…μ„ μ•κΈ° μ„ν•΄μ„λ” ν•¨μμ νƒ€μ…μ„ μ¶”λ΅ ν• λ• λ‹¤μ‹ λ™μΌν• νƒ€μ…μ„ μ•μ•„μ•Ό ν•λ” μ¦‰ `inferTypeParameter > inferType(node.value) > inferTypeFunctionValue() > inferTypeParameter`μΌλ΅ μ΄μ–΄μ§€λ” μν™ κ³ λ¦¬κ°€ μ΅΄μ¬ν•κ² λλ‹¤.

μ—„λ°€ν•κ² λ§ν•μλ©΄ νλΌλ―Έν„° νƒ€μ… μ¶”λ΅ μ΄ μ–΄λ–¤ κ²ƒμ νƒ€μ… μ¶”λ΅  κ³Όμ •μ μ¤‘κ°„μ— μκΈ° λ•λ¬Έμ΄λ‹¤. μ΄ μ¶”λ΅  κ³Όμ •μ΄ λ‚΄κ°€ μ¶”λ΅ ν•λ ¤λ” ν•¨μμ™€ κ΄€λ ¨μ΄ μ—†μΌλ©΄ μƒκ΄€μ—†μ§€λ§ κ΄€λ ¨μ΄ μμΌλ©΄ νλΌλ―Έν„° νƒ€μ… μ¶”λ΅ μ„ ν•λ©΄μ„ μ¶”λ΅  μ¤‘μ΄λ ν•¨μμ— λ€ν•΄μ„ λ‹¤μ‹ μ°Έμ΅°ν•λ ¤ ν•λ©΄ λ°μƒλλ” κ²ƒμ΄λ‹¤. ν•­μƒ κ·Έλ° κ²ƒλ„ μ•„λ‹μ§€λ§ λΉλ²ν•κ² λ°μƒν•λ©° μ¶”λ΅  κ³Όμ •μ΄ λ³µμ΅ν•λ©΄ λ³µμ΅ν• μλ΅ λ°μƒλ  ν™•λ¥ μ΄ λ” λ†’μ•„μ§„λ‹¤.

μ΄ λ¬Έμ λ” μ¶”λ΅ μ‹ μ‚¬μ©ν•λ” cacheλ¥Ό μƒλ΅ ν• λ‹Ήν•λ” λ°©λ²•μΌλ΅ ν•΄κ²°ν•μ€λ‹¤.
νλΌλ―Έν„°λ΅ μ‹μ‘ν•΄μ„ ν•¨μλ“¤μ„ κ±°μ³ νλΌλ―Έν„°μ νƒ€μ…μ„ μ¶”λ΅ ν•λ” κ³Όμ • μμ²΄λ” μν™μ μ΄μ§€ μ•μ„ μ μλ”λ° μ΄ κ³Όμ •μ„ μ²μλ¶€ν„° μ μ–΄ν•  μ μ—†κΈ° λ•λ¬Έμ— λ°μƒν• λ¬Έμ λΌκ³  ν•  μ μλ‹¤. κ·Έλμ„ μ¶”λ΅  κ³Όμ •μ—μ„ μ‚¬μ©ν•λ” cacheλ¥Ό νλΌλ―Έν„°λ¥Ό μ¶”λ΅ ν•  λ•κΉμ§€λ” μ„μ‹μ cacheλ¥Ό μ‚¬μ©ν•λ” λ°©λ²•μΌλ΅ recursive definitionμ„ μ²λ¦¬ν•μ€λ‹¤.

### μ²λ¦¬κ³Όμ •

νλΌλ―Έν„°μ νƒ€μ…μ„ μ¶”λ΅ ν•κΈ° μ„ν•΄μ„λ” κ·Έ νλΌλ―Έν„°λ¥Ό μ‚¬μ©λλ” ν•¨μλ¥Ό μ°Ύμ•„μ•Ό ν•λ‹¤. νλΌλ―Έν„°μ νƒ€μ… μ¶”λ΅ μ—λ” νλΌλ―Έν„°λ¥Ό κ°€μ§€κ³  μλ” ν•¨μκ°€ λ§¤μ° μ¤‘μ”ν•λ‹¤. μ΄ ν•¨μκ°€ κ²°κµ­μ€ νλΌλ―Έν„°μ νƒ€μ…μ„ μΆμ°ν•κΈ° λ•λ¬Έμ΄λ‹¤.

μ΄ ν•¨μλ¥Ό μ°ΎκΈ° μ„ν•΄μ„ Parameterμ Containerλ¥Ό μ‚¬μ©ν•λ‹¤.   
`node.$type`μ΄ Parameterμ΄λ©΄ `node.$container.$type`λ”
FunctionDef, FunctionValue, FunctionTypeμ΄ λ  μ μκ³  λ‹¤μ‹ κ·Έκ²ƒμ containerλ” ν•¨μλ¥Ό νΈμ¶ν•λ” λ¶€λ¶„μ΄ λλ‹¤.  
μ¦‰ λ‹¤μκ³Ό κ°™λ‹¤.

ν•¨μν• λ©”μ„λ“μΈ `corpList.forEach(corp => corp.display())` μ κ²½μ°
|   |   |   |
|---|---|---|
| `node`                       | Parameter     | `corp` |
| `node.$container`            | FunctionValue | `corp => corp.process()` |
| `node.$container.$container` | CallChain     | `corpList.forEach(corp => corp.process())` |

μΌλ° ν•¨μ νΈμ¶μΈ κ²½μ°
```ts
val getSaleDetail = (date: number, callback: (salesDetail: SalesDetail) => string) => { }
getSaleDetail(12, salesDetail => { return salesDetail.salesHistory })
```
|   |   |   |
|---|---|---|
| `node`                       | Parameter     | `salesDetail` |
| `node.$container`            | FunctionValue | `salesDetail => { return salesDetail.salesHistory }` |
| `node.$container.$container` | CallChain     | `getSaleDetail(12, salesDetail => { return salesDetail.salesHistory })` |

μ΄λ ‡κ² μ°Ύμ€ ν•¨μκ°€ μ–΄λ–¤ νƒ€μ…μΈκ°€λ¥Ό μ¶”λ΅ ν•΄μ•Ό ν•λ”λ° μ΄κ²ƒμ€ μ΄ ν•¨μμ μ΄μ „ λ¶€λ¶„μ΄ λ¬΄μ—‡μΈμ§€μ™€ κ΄€λ ¨μ΄ μλ‹¤. μ¦‰ `corpList.forEach`μ—μ„ `corpList`κ°€ λ¬΄μ—‡μΈμ§€λ„ μ•μ•„μ•Ό ν•λ‹¤λ” κ²ƒμ΄λ‹¤. μ΄ chainμ€ κ½¤ κ±°μ¬λ¬ μ¬λΌκ° μλ„ μλ‹¤.

μ–΄μ§Έλ“  μ΄ κ³Όμ •μ„ κ±°μ³μ„ ν•¨μμ νƒ€μ…μ„ μ•μ•„λ‚Ό λ• ν•΄λ‹Ή ν•¨μμ μ λ„¤λ¦­ μ •λ³΄λ„ κ³ λ ¤λμ–΄μ•Ό ν•λ‹¤. 

λ§μ§€λ§‰μΌλ΅ ν•΄λ‹Ή ν•¨μμ μ •ν™•ν• νƒ€μ…μ„ μ°Ύμ•λ‹¤λ©΄ νλΌλ―Έν„°μ νƒ€μ…λ„ μ•μ μλ”λ° λ¬Έμ λ” salesDetailκ³Ό κ°™μ€ νλΌλ―Έν„°κ°€ ν•¨μμ λ‡λ²μ§Έ νλΌλ―Έν„°μΈκ°€λ¥Ό ν‰κ°€ν•΄μ•Ό ν•λ‹¤λ” κ²ƒμ΄λ‹¤. `inferTypeParameter()`μ μ •λ³΄λ΅λ” μ΄κ²ƒμ„ μ• μ μ—†κΈ° λ•λ¬Έμ— λ‹¤μ‹ ν•¨μμ—μ„ μμ‹ μ νλΌλ―Έν„°κ°€ λ‡λ²μ§Έ μΈμ§€λ¥Ό λ³΄κ³  ν•¨μμ νλΌλ―Έν„° μ •λ³΄μ™€ λ§¤μΉν•΄μ„ μμ‹ μ μ‹¤μ  νƒ€μ…μ„ κ²°μ •ν•κ² λλ‹¤.

μ΄λ¥Ό μ„ν•΄μ„ CallChainμ argsλ¥Ό μ‚¬μ©ν•΄μ„ νλΌλ―Έν„°μ μ„μΉλ¥Ό ν•λ‚μ”© λ‹¤ κ²€ν† ν•λ‹¤.

μμ„Έν• κ²ƒμ€ μ½”λ“κ°€ μμ„Έν•κ² μ„¤λ…ν•κ³  μλ‹¤.

```ts
def Corp = {
  val process = () => {
    console.log('process')
  }
}
val corps: Corp[] = []
corps.forEach(corp => corp.process())
```

```
Type of variable 'process' is () -> void
Type of function '() => {
    console.log('process')
  }' is () -> void
π€ ~ checkCallChain: Type of function 'log' is (args: any[]) -> void
Type of variable 'corps' is Corp[]
π€ ~ checkCallChain: Type of function 'forEach' is (callbackFn: (arg: Corp, index: number) -> any, thisArg: any) -> void
Type of function 'corp => corp.process()' is (corp: Corp) -> void
π€ ~ checkCallChain: Type of function 'process' is () -> void
```

μ•„λμ μ½”λ“λ” Bindingμ— λλ‹¤ ν•¨μκ°€ ν¬ν•¨λλ” κ²½μ°μΈλ° Bindingμ€ μΆ€ λ” μ‚΄ν΄λ΄μ•Ό ν•λ‹¤.

```ts
case 'κ΄‘μ‚°' => {
  val nextChain: ChainPrompt = {
    prompt: promptMsg
    createListCallback: (list, options) => {
      return createRsrcList(Rsrc.getRsrcsList(['μ±„κ΄‘μ§€']), list)
    }
  }
  return nextChain
}
case 'λ²λ©' => {
  val nextChain: ChainPrompt = {
    prompt: promptMsg
    createListCallback: (list, options) => {
      return createRsrcList(Rsrc.getRsrcsList(['λ²λ©μ§€']), list)
    }
  }
  return nextChain
}
```

μ‚¬μ‹¤ μ΄ λ¨λ“  λ…Έλ ¥μ΄ λ‹¤μμ ν•κ³„ λ•λ¬Έμ— λ°μƒν• κ²ƒμ΄λ‹¤.

```
val sa: string[] = ['1']
sa.push('2')
```
μ„μ™€ κ°™μ€ κµ¬λ¬Έμ΄ μμ„λ• `n1.push('2')`λΌλ” κ²ƒμ νƒ€μ…μ€ λ¬΄μ—‡μΈκ°€?

μ΄κ²ƒμ€ `var count = sa.push('2')`μ™€ κ°™μ€ κµ¬λ¬Έμ—μ„ λ³΄λ©΄ `number`μ΄λ‹¤.

νλΌλ―Έν„°λ¥Ό λ¶„μ„ν•κΈ° μ„ν•΄μ„λ” Validatorμ `checkCallChain()`μ—μ„ ν•΄μ•Ό ν•λ”λ° μ΄λ• `push`λ¥Ό ν†µν•΄μ„ μ–»κ² λλ” κ²ƒμ΄ numberμΈ κ²ƒμ΄λ‹¤.
`push`μ μμ²΄μ νƒ€μ…μΈ `(element: string[]) -> number`μ„ μ–»κΈ° μ„ν•΄μ„λ” μ–΄λ–»κ² ν•΄μ•Ό ν• κΉ? CallChainμ΄ ν•¨μμ νΈμ¶(μ¦‰ μ‚¬μ©)μ„ ν¬ν•¨ν•λ” κ²ƒμ€ λ¬Έμ κ°€ μ•λλ”λ° μ‚¬μ©μ‹ μΈμλ¥Ό κ²€μ‚¬ν•κΈ° μ„ν•΄μ„ ν•¨μμ νλΌλ―Έν„° μ •λ³΄λ¥Ό μ–»μ–΄λ ¤κ³  ν•  λ• CallChainμ νƒ€μ…μ΄ μ „ν€ λ„μ›€μ΄ μ•λκ³  μλ‹¤.

κ·Έλμ„ μ—„μ²­λ‚ λ…Έλ ¥μ„ λ“¤μ—¬ `getFunctionInfo()`λ¥Ό λ§λ“¤μ—κ³  λ‹¤μ‹ `InferResult`λ΅ λ³€κ²½ν•λ©΄μ„ `actual`, `formal`λ΅ κµ¬λ¶„λκ² ν• κ²ƒμ΄λ‹¤.

μ΄ λ¬Έμ λ¥Ό `checkCallChain`μ΄ μ•„λ‹λΌ `checkParameter`μ—μ„ ν•λ ¤κ³  ν•΄λ„ μ΄ ν•¨μ μμ²΄κ°€ μ• λ¶λ¦°λ‹¤. μ™λƒν•λ©΄ `'2'`λ” νλΌλ―Έν„°κ°€ μ•„λ‹λΌ μΈμμ΄κΈ° λ•λ¬Έμ— νλΌλ―Έν„° μμ²΄κ°€ μ—†λ‹¤. μ΄ ν•¨μκ°€ νΈμ¶λλ‹¤κ³  ν•΄λ„ λ‹¤ ν•΄κ²°λλ” κ²ƒλ„ μ•„λ‹λ‹¤.

